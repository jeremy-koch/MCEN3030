{"version":2,"kind":"Article","sha256":"30c2886c3d86761683726e4d4de3c27faf6427e1763b61f4bc4f162952f9248b","slug":"lu-starter","location":"/4_matrix/LU_starter.md","dependencies":[],"frontmatter":{"title":"LU Decomposition Starter","content_includes_title":false,"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"LU_starter.md","url":"/LU_starter-b88a6d369aa863a888494cb500fbf573.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Here are some skeleton codes to get you started","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"AWSGCQ36FC"}],"key":"dIYiWvjfSf"},{"type":"heading","depth":2,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"LU Decomposition","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"nUSgLoTGpR"}],"identifier":"lu-decomposition","label":"LU Decomposition","html_id":"lu-decomposition","implicit":true,"key":"CXkeoJKzUe"},{"type":"tabSet","children":[{"type":"tabItem","title":"MATLAB","children":[{"type":"code","lang":"matlab","value":"function [L,U] = LU_decomp(A)\n% LU_decomp performs the LU decomposition on a general matrix A using \n%   input:      A= a square matrix\n%   outputs:    L= a lower-triangular matrix\n%               U= an upper-triangular matrix\n\nn=length(A);    % length of a matrix is its number of columns.\n\nU=A;            % Initialize U as A, though it is not U yet -- must iterate.\nL=eye(size(A)); % L has 1s along its diagonal, initialize with \"eye\"\n\n% Big-picture: we go through elements 2->n in the first column to get an\n% intermediate matrix, and then 3->n in the second column ... we will\n% use nested for loops.\n\nfor i=1:n-1     % row i, multiplied by a scalar, is used to change...\n    for j=?:? % ... row j\n        k= % the multiplier\n        U(?,?)=U(?,?)-k*U(?,?); % make sure not to change the rows before i!\n        L(?,?)=k;\n    end\nend\n\nend","position":{"start":{"line":9,"column":1},"end":{"line":34,"column":1}},"key":"ndohL6gkfF"}],"key":"PpQaIUjieZ"},{"type":"tabItem","title":"Python","children":[{"type":"paragraph","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Donâ€™t forget Python indexes from zero!","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"OKDNYfvPpQ"}],"key":"bkTipxitHv"},{"type":"code","lang":"python","value":"import numpy as np\n\ndef LU_decomp(A):\n    # LU_decomp performs the LU decomposition on a general matrix A using \n    #   input:      A= a square matrix\n    #   outputs:    L= a lower-triangular matrix\n    #               U= an upper-triangular matrix\n\n    n = len(A)    # length of a matrix is its number of columns.\n\n    U = A.copy()           # Initialize U as A, though it is not U yet -- must iterate.\n    L = np.eye(A.shape[0]) # L has 1s along its diagonal, initialize with \"eye\"\n\n    # Big-picture: we go through elements 2->n in the first column to get an\n    # intermediate matrix, and then 3->n in the second column ... we will\n    # use nested for loops.\n\n    for i in range(n-1):     # row i, multiplied by a scalar, is used to change...\n        for j in range(?, ?): # ... row j\n            k = ? # the multiplier\n            U[?, ?] = U[?, ?] - k * U[?, ?] # make sure not to change the rows before i!\n            L[?, ?] = k\n            \n    return L, U","position":{"start":{"line":40,"column":1},"end":{"line":65,"column":1}},"key":"bekWfqcQvF"}],"key":"hxmzPtuZGS"},{"type":"tabItem","title":"Julia","children":[{"type":"code","lang":"julia","value":"using LinearAlgebra\n\nfunction LU_decomp(A)\n    # LU_decomp performs the LU decomposition on a general matrix A using \n    #   input:      A= a square matrix\n    #   outputs:    L= a lower-triangular matrix\n    #               U= an upper-triangular matrix\n\n    n = size(A, 2)    # length of a matrix is its number of columns.\n\n    U = copy(A)       # Initialize U as A, though it is not U yet -- must iterate.\n    L = Matrix{Float64}(I, size(A)) # L has 1s along its diagonal, initialize with \"eye\" (requires `using LinearAlgebra`)\n\n    # Big-picture: we go through elements 2->n in the first column to get an\n    # intermediate matrix, and then 3->n in the second column ... we will\n    # use a nested for loop.\n\n    for i = 1:n-1     # row i, multiplied by a scalar, is used to change...\n        for j = ?:?   # ... row j\n            k = ?     # the multiplier\n            U[?, ?] = U[?, ?] - k * U[?, ?] # make sure not to change the rows before i!\n            L[?, ?] = k\n        end\n    end\n\n    return L, U\nend","position":{"start":{"line":70,"column":1},"end":{"line":98,"column":1}},"key":"f5FrkhAGoj"}],"key":"SvYKk3vvHa"}],"key":"fOEbZdYD7M"},{"type":"heading","depth":2,"position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Forward-Substitution Algorithm","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"i1GiEGXEgW"}],"identifier":"forward-substitution-algorithm","label":"Forward-Substitution Algorithm","html_id":"forward-substitution-algorithm","implicit":true,"key":"YpPtsB5QMC"},{"type":"tabSet","children":[{"type":"tabItem","title":"MATLAB","children":[{"type":"code","lang":"matlab","value":"function [d] = forward_sub(L,b)\n% forward_sub uses the forward-substitution algorithm to solve the equation\n% Ld = b for a lower-triangular matrix L\n% inputs:   L= a lower-triangular matrix\n%           b= a vector \"forcing function\"\n% output:   x= the solution to Ld = b\n\nn=length(b);\nd=zeros(size(b));\n\n% Use a for loop that counts from i=1 to n.\n% Within that loop, you will need to calculate a new sum each time.\n% I recommend re-initializing a variable called S, at zero,\n% and then computing the sum with a second for loop.\n\nend","position":{"start":{"line":107,"column":1},"end":{"line":124,"column":1}},"key":"zDxXFDvmtq"}],"key":"ieqDX7Qib0"},{"type":"tabItem","title":"Python","children":[{"type":"code","lang":"python","value":"import numpy as np\n\ndef forward_sub(L, b):\n    # forward_sub uses the forward-substitution algorithm to solve the equation\n    # Ld = b for a lower-triangular matrix L\n    # inputs:   L= a lower-triangular matrix\n    #           b= a vector \"forcing function\"\n    # output:   x= the solution to Ld = b\n\n    n = len(b)\n    d = np.zeros(b.shape)\n\n    # Use a for loop that counts from i=1 to n.\n    # Within that loop, you will need to calculate a new sum each time.\n    # I recommend re-initializing a variable called S, at zero,\n    # and then computing the sum with a second for loop.\n    \n    return d","position":{"start":{"line":129,"column":1},"end":{"line":148,"column":1}},"key":"ddMdgUgDjt"}],"key":"WSaz8Hn6C0"},{"type":"tabItem","title":"Julia","children":[{"type":"code","lang":"julia","value":"function forward_sub(L, b)\n    # forward_sub uses the forward-substitution algorithm to solve the equation\n    # Ld = b for a lower-triangular matrix L\n    # inputs:   L= a lower-triangular matrix\n    #           b= a vector \"forcing function\"\n    # output:   x= the solution to Ld = b\n\n    n = length(b)\n    d = zeros(size(b))\n\n    # Use a for loop that counts from i=1 to n.\n    # Within that loop, you will need to calculate a new sum each time.\n    # I recommend re-initializing a variable called S, at zero,\n    # and then computing the sum with a second for loop.\n\n    return d\nend","position":{"start":{"line":153,"column":1},"end":{"line":171,"column":1}},"key":"ceFS3vk3tE"}],"key":"Nbko1ldtKD"}],"key":"E0bd5B8fK8"},{"type":"heading","depth":2,"position":{"start":{"line":177,"column":1},"end":{"line":177,"column":1}},"children":[{"type":"text","value":"Backward-Substitution Algorithm","position":{"start":{"line":177,"column":1},"end":{"line":177,"column":1}},"key":"aUIS0jdtiG"}],"identifier":"backward-substitution-algorithm","label":"Backward-Substitution Algorithm","html_id":"backward-substitution-algorithm","implicit":true,"key":"QncIDlpzO4"},{"type":"tabSet","children":[{"type":"tabItem","title":"MATLAB","children":[{"type":"code","lang":"matlab","value":"function [x] = back_sub(U,d)\n% backsub uses the back-substitution algorithm to solve the equation Ux = d\n% for an upper-triangular matrix U\n% inputs:   U= an upper-triangular matrix\n%           d= modified forcing function, as in Ld=b\n% output:   x= the solution to Ux = d\n\nn=length(d);\nx=zeros(size(d));\n\n% Use a for loop that counts backwards from i=n to 1.\n% Within that loop, you will need to calculate a new sum each time.\n% I recommend re-initializing a variable called S, at zero,\n% and then computing the sum with a second for loop.\n\nend","position":{"start":{"line":181,"column":1},"end":{"line":198,"column":1}},"key":"VdaBLqyUOc"}],"key":"cb7u7MCmhj"},{"type":"tabItem","title":"Python","children":[{"type":"code","lang":"python","value":"import numpy as np\n\ndef back_sub(U, d):\n    # backsub uses the back-substitution algorithm to solve the equation Ux = d\n    # for an upper-triangular matrix U\n    # inputs:   U= an upper-triangular matrix\n    #           d= modified forcing function, as in Ld=b\n    # output:   x= the solution to Ux = d\n\n    n = len(d)\n    x = np.zeros(d.shape)\n\n    # Use a for loop that counts backwards from i=n to 1.\n    # Within that loop, you will need to calculate a new sum each time.\n    # I recommend re-initializing a variable called S, at zero,\n    # and then computing the sum with a second for loop.\n\n    return x","position":{"start":{"line":203,"column":1},"end":{"line":222,"column":1}},"key":"javlhwDtDI"}],"key":"SE48tUoT15"},{"type":"tabItem","title":"Julia","children":[{"type":"code","lang":"julia","value":"function back_sub(U, d)\n    # backsub uses the back-substitution algorithm to solve the equation Ux = d\n    # for an upper-triangular matrix U\n    # inputs:   U= an upper-triangular matrix\n    #           d= modified forcing function, as in Ld=b\n    # output:   x= the solution to Ux = d\n\n    n = length(d)\n    x = zeros(size(d))\n\n    # Use a for loop that counts backwards from i=n to 1.\n    # Within that loop, you will need to calculate a new sum each time.\n    # I recommend re-initializing a variable called S, at zero,\n    # and then computing the sum with a second for loop.\n\n    return x\nend","position":{"start":{"line":227,"column":1},"end":{"line":245,"column":1}},"key":"vzmAMRKM0g"}],"key":"G1vXfHohO8"}],"key":"M6bGnTyeSE"}],"key":"mkvkEEJMvm"}],"key":"EKLvmZ8ciX"},"references":{"cite":{"order":[],"data":{}}}}